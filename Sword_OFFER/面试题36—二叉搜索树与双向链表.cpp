// 面试题36―二叉搜索树与双向链表
// 题目：输入一个复杂链表
// （每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点，
// 返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

#include <iostream>
#include <vector>
#include <map>
#include "BinaryTree.h"
using namespace std;

class Solution 
{
public:
	//试着采用中序遍历思想实现
	BinaryTreeNode* pre = nullptr;
	BinaryTreeNode* head = nullptr;
	BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)
	{
		if (pRootOfTree == nullptr)
			return nullptr;
		ConvertNode(pRootOfTree);
		return head;
	}
	void ConvertNode(BinaryTreeNode* pRootOfTree)
	{
		if (pRootOfTree == nullptr)
			return;
		ConvertNode(pRootOfTree->m_pLeft);
	}
};