#include <iostream>
#include <vector>
using namespace std;

//1.递归解法：这是一个不断地试探回溯的过程，所以这是一个标准的试探回溯递归法（类似深度优先搜索算法）
//从最普通的个位数1开始试探，不断地使用未使用的值来*10扩充，尝试是否有符合条件的数，若没有则回溯到最开始，乃至个数为1时，使其递增为2再继续试探
//很有意思的一点是，递归的试探回溯是建立在循环的基础上的，而迭代的试探回溯也是循环为蓝本

int used[10] = {0};  //记录对应位数是否使用的数组，0未使用，1使用
vector<long long> save;		//记录所符合条件的所有数组

//k初始化为0，表示从数字0开始找整除，a初始化为0，表达从0开始找到987654321
void findthenumber_DFS(int k, long long a)
{
	//1.递归基，前面的k为在k=a=0时的一个保护，后面的为不满足当前数a整除k的情况
	if (k && a%k != 0)
		return;
	//2.当此时满足k==9时，表示此时的a已经满足了题目条件，将其存储并return结束此次遍历
	if (k == 9)
	{
		save.push_back(a);
		return;
	}
	//3.线性递归，实现功能的核心，思想为试探回溯法，不过不需要做回溯标记，其会跟着循环自己回来
	//循环中的多个线性递归，在某种意义上，直接就是组合成了一种多向递归，最后的结果仍然是多叉树结构
	for (int i = 1; i < 10; i++)
	{
		//3.1首先判断当前数字是否被使用过，被使用过则跳过到下一个数字
		if (!used[i])
		{
			used[i] = 1;
			//3.2线性递归的实现，具体为将下一个需要整除的数k，与整合当前能使用数字后的数字a带入递归
			findthenumber_DFS(k + 1, a * 10 + i);
			//3.3每当前面的一个递归结束，无论其是否找到，均将当前数据复位，便于继续查找
			used[i] = 0;
		}
	}
}

int main_qiannweibeizhengchu()
{
	findthenumber_DFS(0, 0);
	for (auto&s : save)
		cout << "找到的数有：" << s;
	cout << endl;

	return 0;
}