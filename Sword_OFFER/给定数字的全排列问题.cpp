#include <iostream>
#include <list>
using namespace std;

/*
					abc
			a bc    b ac    c ba	  其上的枝节点都在过循环
		  abc acb  bac bca  cba cab   到达递归基的多叉树叶节点

  全排列递归的意义：固定前i，全排列i+1后所有，所有结果成多叉树结构，整体运行操作就是按序访问所有叶节点（每访问完一个叶节点就要复位）
*/

//全排列问题，相当于固定前i位，对第i+1位之后的数据再进行全排列
//list数组存放排列的数，k表示为当前的第几个数，m表示数组的长度
void Perm(int list[], int k, int m)
{
	//1.递归基为当前所处的位数达到了最后一位
	if (k == m - 1)
	{
		//1.1每当访问到叶节点时，依照当前数组内部的结构，输出结果，表示该分支遍历完成
		for (int i = 0; i < m; i++)
			cout << list[i];
		cout << endl;
	}
	else 
	{
		//2.全排列算法的核心：固定前i位，对i+1后的数据再进行全排列
		for (int i = k; i < m; i++) //每一层循环就是多叉树的一层，而每层的尽头就是底下的各个分支结束（也就是说，能到这个循环的，都是倒数第二层叶节点）
		{
			//2.1 for循环通过交换数字来实现全排列，这里从k开始，每个k之后的值都会被交换一遍
			swap(list[i], list[k]);
			//2.2 线性递归，逐渐缩小范围（每个大循环下面都包含有大量的小循环，每完成一个最底层的小循环则将该小循环所换的数换回来，用于下一次小循环）
			Perm(list, k + 1, m);
			//2.3 这里是还原数组，保证每一步的计算都能按循环初始时实现（最后计算完成后数组仍为原型）
			swap(list[i], list[k]);
		}
	}
}

int main_Perm()
{
	int a[] = { 1,2,3,4 };
	Perm(a, 0, 4);
	for (int i = 0; i < 4; i++)
		cout << "a[" << i << "]:" << a[i] << endl;

	return 0;
}