/*递归的基本思想
1.个人总结，递归适合从大往小推，而循环适合从小往大推，而递归难以实现从小往大，但是循环却可以实现从大往小）
2.递归就是递和归，递到最基本的递归基之后根据之前的路归回去；而循环往往就直接是归回去这条路，但是没有递的路标就往往很难走
3.递归就是把整个计算的路直接走完了，然后根据递归基走回去一遍把坑填了；循环就是不知道自己走多远的路，直到限制条件出现挡住了
总结：递归就是从计算的终点走到起点再走到终点，循环就是从起点走到终点

零、递归的实际分类
1.线性递归，单向的递归，一条路走到死
2.多向递归，在递归的过程中可能出现多种不同的方向，但是最终也只能选择一个方向，属于线性递归的一种
3.多路递归：具体就是递归分成了f(n)+f(n-1)之类的不同道路，其每一个子递归都可能再做多次递归（通常都是一分为二，故也称二分地轨）。这种递归方式可以直接用多叉树结构来理解，递归基就是叶节点；
4.尾递归：递归调用在递归实例中恰好是最后一步操作，这种递归都能易于变为迭代版本

一、在函数定义中使用自身函数的方法，有递且必有归
具体分类有：线性递归、多向递归与多路递归（包括二分递归）

二、递归的必须（非必须）具有的四个步骤：
1.明确递归的终止条件；
2.给出递归终止时的处理方法；
3.明确当前问题的特定解决方案（有些情况下不用解决，只用返回）；
4.提取重复的逻辑，缩小问题的规模；

三、递归的基本类型简单地描述为：
（1）在递的过程中解决问题
function recursion(大规模)
{
	if(end_condition)		//1.明确的停止条件
		end;				//2.在停止时所执行的解决方案
	else
	{
		solve;				//3.在递的过程中，即划分问题前的解决方案
		recursion(小规模);	//4.缩小运行规模
	}
}

（2）在归的过程中解决问题
function recursion(大规模)
{
	if(end_condition)		//1.明确的停止条件
		end;				//2.在停止时所执行的解决方案
	else
	{
		recursion(小规模);	//3.缩小运行规模
		solve;				//4.在归的过程中，即划分问题后的解决方案
	}
}

（3）多路递归时，在多路递归时（如二叉树的迭代遍历），对于不同的路来说，解决方案可处于递或者归的位置
function recursion(大规模)
{
	if(end_condition)		//1.明确的停止条件
		end;				//2.在停止时所执行的解决方案
	else
	{
		recursion1(小规模);	//3.缩小运行规模，子规模1
		solve;				//4.对于不同的子递归，其所处的位置不同
		recursion2(小规模);	//5.缩小运行规模，子规模2
	}
}

（4）特例，solve的位置总是飘忽不定，可能在递过程或归过程，也可能在停止解决方案中，也可能不出现，所以其不是必须的

*/